package com.example.reactrumble.minigames

import android.annotation.SuppressLint
import android.graphics.Color
import android.os.Bundle
import android.os.CountDownTimer
import android.widget.LinearLayout
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import com.example.reactrumble.R
import com.example.reactrumble.controllers.GameManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlin.random.Random

@SuppressLint("ClickableViewAccessibility")
class MathGame : AppCompatActivity() {

	private val gameInstructions = "Tap if equations are correct!"

	private lateinit var equationTimer: CountDownTimer

	private var tapCount: Int = 0
	private var isGamePaused: Boolean = false

	companion object {
		// Number of rounds taken from Game Manager
		private const val MAX_GAME_TIME = 600000L
		private var maxGameTaps = GameManager.maxRoundsPerMiniGame
		private val COLOR_CORRECT = Color.parseColor("#C947D86B")
		private val COLOR_INCORRECT = Color.parseColor("#D34A4A")
		private val COLOR_DEFAULT = Color.parseColor("#A9A9C8")
	}

	override fun onCreate(savedInstanceState: Bundle?) {
		maxGameTaps = GameManager.maxRoundsPerMiniGame
		super.onCreate(savedInstanceState)

		setContentView(R.layout.math_minigame)
		startGame()
	}

	// This method is run to start the game, it displays the game instructions and then runs the
	// startEquationGeneration() method
	private fun startGame() {
		val countdownTextP1: TextView = findViewById(R.id.countdownTextP1)
		val countdownTextP2: TextView = findViewById(R.id.countdownTextP2)
		val player1instructions: TextView = findViewById(R.id.player1_instructions)
		val player2instructions: TextView = findViewById(R.id.player2_instructions)

		countdownTextP1.text = gameInstructions
		countdownTextP2.text = gameInstructions
		player1instructions.text = gameInstructions
		player2instructions.text = gameInstructions

		// Set Initial Player Scores from previous games
		updateScoreText()

		// Delay the start of the game to allow players to read the instructions
		GlobalScope.launch(Dispatchers.Main) {
			delay(GameManager.gameDelayTime)
			countdownTextP1.text = ""
			countdownTextP2.text = ""
			startEquationGeneration()
		}
	}

	// This method initializes the player touch zones and is used to handle each equation generated by
	// calling generateEquation on a set timer
	private fun startEquationGeneration() {
		// Start the countdown timer for generating equations
		equationTimer = object : CountDownTimer(MAX_GAME_TIME, GameManager.gameDelayTime) {
			override fun onTick(millisUntilFinished: Long) {
				if (!isGamePaused) {
					val player1Zone: LinearLayout = findViewById(R.id.player1_zone)
					val player2Zone: LinearLayout = findViewById(R.id.player2_zone)
					player1Zone.isEnabled = true
					player1Zone.setBackgroundColor(COLOR_DEFAULT)
					player2Zone.isEnabled = true
					player2Zone.setBackgroundColor(COLOR_DEFAULT)
					generateEquation()
				}
			}

			override fun onFinish() {
				// Call Next Game or Game Over Screen after the game duration is over
				GameManager.nextGame(this@MathGame)
			}
		}
		equationTimer.start()
	}

	// Generates a correct or incorrect (by chance) mathematical equation and displays it on the screen
	private fun generateEquation() {
		val player1Zone: LinearLayout = findViewById(R.id.player1_zone)
		val player2Zone: LinearLayout = findViewById(R.id.player2_zone)
		val equationTextP1: TextView = findViewById(R.id.equationTextP1)
		val equationTextP2: TextView = findViewById(R.id.equationTextP2)

		// Generate random numbers and an operator for the equation
		val number1 = Random.nextInt(10)
		val number2 = Random.nextInt(10)
		val operator = if (Random.nextBoolean()) "+" else "-"
		val correctResult = if (operator == "+") number1 + number2 else number1 - number2

		// 50% chance of getting a correct or incorrect answer
		val isCorrectEquation = Random.nextBoolean()

		var incorrectResultOffset = Random.nextInt(-5, 5)
		while (incorrectResultOffset == 0) {
			// Generate a non-zero offset to ensure incorrect equations have different results
			incorrectResultOffset = Random.nextInt(-5, 5)
		}
		val result = if (isCorrectEquation) correctResult else correctResult + incorrectResultOffset

		equationTextP1.text = "$number1 $operator $number2 = $result"
		equationTextP2.text = "$number1 $operator $number2 = $result"

		// Set click listeners for each player's touch zone to handle the taps
		player1Zone.setOnClickListener {
			handleTap(isCorrectEquation, player1Zone, equationTextP1)
			checkGameOver(player1Zone, player2Zone)
		}

		player2Zone.setOnClickListener {
			handleTap(isCorrectEquation, player2Zone, equationTextP2)
			checkGameOver(player1Zone, player2Zone)
		}
	}

	private fun handleTap(isCorrect: Boolean, playerZone: LinearLayout, equationText: TextView) {
		// Handle player tap by changing the background color based on the correctness of the equation
		if (isCorrect) {
			playerZone.setBackgroundColor(COLOR_CORRECT)
			increaseScore(playerZone, equationText)
		} else {
			playerZone.setBackgroundColor(COLOR_INCORRECT)
			decreaseScore(playerZone, equationText)
		}

		// Disable player zones temporarily to prevent multiple taps
		disablePlayerZones()
	}

	private fun increaseScore(playerZone: LinearLayout, equationText: TextView) {
		// Increment the score and provide feedback to the player
		when (playerZone.id) {
			R.id.player1_zone -> GameManager.playerOneScore++
			R.id.player2_zone -> GameManager.playerTwoScore++
		}
		equationText.text = "AWESOME JOB!"
		updateScoreText()
	}

	private fun decreaseScore(playerZone: LinearLayout, equationText: TextView) {
		// Decrement the score and provide feedback to the player
		when (playerZone.id) {
			R.id.player1_zone -> GameManager.playerOneScore--
			R.id.player2_zone -> GameManager.playerTwoScore--
		}
		equationText.text = "BOO! YOU SUCK!"
		updateScoreText()
	}

	private fun updateScoreText() {
		// Update the displayed scores on the screen to reflect the current scores
		val player1DisplayScore: TextView = findViewById(R.id.player1_score)
		val player2DisplayScore: TextView = findViewById(R.id.player2_score)
		player1DisplayScore.text = "SCORE: ${GameManager.playerOneScore}"
		player2DisplayScore.text = "SCORE: ${GameManager.playerTwoScore}"
	}

	private fun disablePlayerZones() {
		// Temporarily disable player touch zones to avoid multiple taps during a brief pause
		val player1Zone: LinearLayout = findViewById(R.id.player1_zone)
		val player2Zone: LinearLayout = findViewById(R.id.player2_zone)
		player1Zone.isEnabled = false
		player2Zone.isEnabled = false
		isGamePaused = true
		GlobalScope.launch(Dispatchers.Main) {
			delay(GameManager.gameDelayTime)
			isGamePaused = false
		}
	}

	private fun checkGameOver(player1Zone: LinearLayout, player2Zone: LinearLayout) {
		// Check if the game is over based on the number of taps, and proceed accordingly
		if (++tapCount >= maxGameTaps) {
			player1Zone.isClickable = false
			player2Zone.isClickable = false
			// Delay before ending the game to allow players to check the results of the last round
			GlobalScope.launch(Dispatchers.Main) {
				delay(GameManager.gameDelayTime)
				equationTimer.cancel()
				equationTimer.onFinish()
			}
		}
	}

	// If the back button is pressed during a game session, it will take you straight
	// to the game over screen
	override fun onBackPressed() {
		GameManager.gameOver(this)
	}

}